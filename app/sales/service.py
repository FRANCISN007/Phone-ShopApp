from sqlalchemy.orm import Session
from fastapi import HTTPException
from datetime import datetime
from typing import Optional
from datetime import datetime, time
from datetime import date
from sqlalchemy.orm import joinedload
from sqlalchemy import and_
from app.users.models import User  # adjust import if needed

from . import models, schemas
from app.stock.inventory import service as inventory_service
from app.stock.products import models as product_models

from app.sales.schemas import SaleOut, SaleOut2, SaleSummary, SalesListResponse, SaleItemOut2, SaleItemOut

from app.stock.products import models as product_models
from app.payments.models import Payment

from sqlalchemy import func
from app.stock.products.models import Product

from sqlalchemy import func, desc
from sqlalchemy import text

from app.purchase.models import Purchase





def create_sale_full(
    db: Session,
    sale_data: schemas.SaleFullCreate,
    user_id: int
):
    """
    Create a sale with all items in one transaction.
    Invoice number is auto-generated by PostgreSQL.
    Allows negative stock but returns warnings.
    """

    warnings = []  # üî• collect stock warnings

    # 1Ô∏è‚É£ Create Sale Header
    sale = models.Sale(
        invoice_date=sale_data.invoice_date,
        customer_name=sale_data.customer_name,
        customer_phone=sale_data.customer_phone,
        ref_no=sale_data.ref_no,
        sold_by=user_id,
        total_amount=0

    )

    db.add(sale)
    db.commit()
    db.refresh(sale)

    total_amount = 0

    # 2Ô∏è‚É£ Process Sale Items
    for item in sale_data.items:

        # üîπ Validate product
        product = (
            db.query(product_models.Product)
            .filter(product_models.Product.id == item.product_id)
            .first()
        )

        if not product:
            raise HTTPException(
                status_code=404,
                detail=f"Product {item.product_id} not found"
            )

        # üîπ Check stock (NO BLOCKING)
        stock = inventory_service.get_inventory_orm_by_product(
            db, item.product_id
        )

        if not stock:
            warnings.append(
                f"No stock record for {product.name}. Sale allowed."
            )
        elif stock.current_stock < item.quantity:
            warnings.append(
                f"Insufficient stock for {product.name}. "
                f"Available: {stock.current_stock}, Sold: {item.quantity}"
            )

        # üîπ Deduct stock anyway (can go negative)
        inventory_service.remove_stock(
            db,
            item.product_id,
            item.quantity,
            commit=False
        )

        # üîπ Calculate totals
        item_total = item.quantity * item.selling_price

        sale_item = models.SaleItem(
            sale_invoice_no=sale.invoice_no,
            product_id=item.product_id,
            quantity=item.quantity,
            selling_price=item.selling_price,
            total_amount=item_total
        )

        total_amount += item_total
        db.add(sale_item)

    # 3Ô∏è‚É£ Update Sale Total
    sale.total_amount = total_amount
    db.commit()
    db.refresh(sale)

    # üî• Attach warnings dynamically
    sale.warnings = warnings

    return sale


# ============================================================
# ADD SINGLE ITEM TO EXISTING SALE
# ============================================================

def create_sale_item(
    db: Session,
    item: schemas.SaleItemCreate
):
    """
    Add a single item to an existing sale.
    Invoice number remains unchanged.
    """

    # ‚úÖ Find sale using invoice_no
    sale = (
        db.query(models.Sale)
        .filter(models.Sale.invoice_no == item.sale_invoice_no)
        .first()
    )
    if not sale:
        raise HTTPException(
            status_code=404,
            detail="Sale not found"
        )

    # Validate product
    product = (
        db.query(product_models.Product)
        .filter(product_models.Product.id == item.product_id)
        .first()
    )
    if not product:
        raise HTTPException(
            status_code=404,
            detail="Product not found"
        )

    # Validate stock
    stock = inventory_service.get_inventory_orm_by_product(
        db, item.product_id
    )
    if not stock or stock.current_stock < item.quantity:
        raise HTTPException(
            status_code=400,
            detail="Insufficient stock"
        )

    # Deduct stock
    inventory_service.remove_stock(
        db,
        item.product_id,
        item.quantity,
        commit=False
    )

    total = item.quantity * item.selling_price

    # ‚úÖ USE invoice_no
    sale_item = models.SaleItem(
        sale_invoice_no=item.sale_invoice_no,
        product_id=item.product_id,
        quantity=item.quantity,
        selling_price=item.selling_price,
        total_amount=total
    )

    # Update sale total
    sale.total_amount += total

    db.add(sale_item)
    db.commit()
    db.refresh(sale_item)

    return sale_item


    




def list_item_sold(
    db: Session,
    start_date: date,
    end_date: date,
    invoice_no: Optional[int] = None,
    product_id: Optional[int] = None,
    product_name: Optional[str] = None,
    skip: int = 0,
    limit: int = 100
):
    query = (
        db.query(models.Sale)
        .options(
            joinedload(models.Sale.items)
            .joinedload(models.SaleItem.product)
        )
        .filter(models.Sale.invoice_date >= start_date)
        .filter(models.Sale.invoice_date <= end_date)
    )

    if invoice_no:
        query = query.filter(models.Sale.invoice_no == invoice_no)

    sales = (
        query
        .order_by(models.Sale.invoice_no.desc())
        .offset(skip)
        .limit(limit)
        .all()
    )

    total_qty = 0
    total_amount = 0.0
    sales_out: list[SaleOut] = []

    for sale in sales:
        items_out = []

        for item in sale.items:

            # üîé PRODUCT FILTERS
            if product_id and item.product_id != product_id:
                continue

            if product_name and (
                not item.product
                or product_name.lower() not in item.product.name.lower()
            ):
                continue

            qty = item.quantity or 0
            amt = item.total_amount or 0.0

            total_qty += qty
            total_amount += amt

            items_out.append(
                SaleItemOut(
                    id=item.id,
                    sale_invoice_no=item.sale_invoice_no,
                    product_id=item.product_id,
                    product_name=item.product.name if item.product else None,
                    quantity=qty,
                    selling_price=item.selling_price,
                    total_amount=amt
                )
            )

        # ‚õî Skip sales with no matching items
        if not items_out:
            continue

        sales_out.append(
            SaleOut(
                id=sale.id,
                invoice_no=sale.invoice_no,
                invoice_date=sale.invoice_date,
                customer_name=sale.customer_name or "-",
                customer_phone=sale.customer_phone or "-",
                ref_no=sale.ref_no or "-",
                total_amount=sum(i.total_amount for i in items_out),
                sold_by=sale.sold_by,
                sold_at=sale.sold_at,
                items=items_out
            )
        )

    return {
        "sales": sales_out,
        "summary": {
            "total_quantity": total_qty,
            "total_amount": total_amount
        }
    }



def list_sales(
    db: Session,
    skip: int = 0,
    limit: int = 100,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
):
    # üîπ Base query with eager loading (prevents N+1)
    query = (
        db.query(models.Sale)
        .options(
            joinedload(models.Sale.items)
                .joinedload(models.SaleItem.product),
            joinedload(models.Sale.payments),  # ‚úÖ IMPORTANT
        )
    )

    # üîπ Safe date filters
    try:
        if start_date:
            query = query.filter(
                models.Sale.sold_at >= datetime.combine(start_date, time.min)
            )
        if end_date:
            query = query.filter(
                models.Sale.sold_at <= datetime.combine(end_date, time.max)
            )
    except Exception as e:
        raise HTTPException(
            status_code=400,
            detail=f"Invalid date filter: {e}",
        )

    # üîπ Fetch sales
    sales = (
        query
        .order_by(models.Sale.sold_at.desc())
        .offset(skip)
        .limit(limit)
        .all()
    )

    sales_list: list[SaleOut2] = []
    total_sales_amount = 0.0
    total_paid_sum = 0.0
    total_balance_sum = 0.0

    for sale in sales:
        total_amount = float(sale.total_amount or 0)

        payments = sale.payments or []
        total_paid = sum(float(p.amount_paid or 0) for p in payments)
        balance_due = total_amount - total_paid

        # üîπ Payment status
        if total_paid == 0:
            status = "pending"
        elif balance_due > 0:
            status = "part_paid"
        else:
            status = "completed"

        # üîπ Sale items
        items = [
            SaleItemOut2(
                id=item.id,
                sale_invoice_no=item.sale_invoice_no,
                product_id=item.product_id,
                product_name=item.product.name if item.product else None,
                quantity=item.quantity,
                selling_price=item.selling_price,
                total_amount=item.total_amount,
            )
            for item in (sale.items or [])
        ]

        sales_list.append(
            SaleOut2(
                id=sale.id,
                invoice_no=sale.invoice_no,
                invoice_date=sale.invoice_date,
                customer_name=sale.customer_name or "Walk-in",
                customer_phone=sale.customer_phone,
                ref_no=sale.ref_no,
                total_amount=total_amount,
                total_paid=total_paid,
                balance_due=balance_due,
                payment_status=status,
                sold_at=sale.sold_at,
                items=items,
            )
        )

        total_sales_amount += total_amount
        total_paid_sum += total_paid
        total_balance_sum += balance_due

    # üîπ Summary (ALWAYS returned)
    summary = SaleSummary(
        total_sales=total_sales_amount,
        total_paid=total_paid_sum,
        total_balance=total_balance_sum,
    )

    # ‚úÖ ALWAYS return predictable structure
    return {
        "sales": sales_list,
        "summary": summary,
    }


def update_sale(db: Session, invoice_no: int, sale_update: schemas.SaleUpdate):
    sale = (
        db.query(models.Sale)
        .filter(models.Sale.invoice_no == invoice_no)
        .first()
    )

    if not sale:
        raise HTTPException(status_code=404, detail="Sale not found")

    update_data = sale_update.dict(exclude_unset=True)

    # üî• SAFETY GUARD
    if "invoice_no" in update_data:
        raise HTTPException(
            status_code=400,
            detail="Invoice number cannot be updated"
        )

    for field, value in update_data.items():
        setattr(sale, field, value)

    # totals must come from items
    sale.total_amount = sum(item.total_amount for item in sale.items)

    total_paid = sum(p.amount_paid for p in sale.payments)
    sale.balance_due = sale.total_amount - total_paid

    db.commit()
    db.refresh(sale)

    return sale

def update_sale_item(
    db: Session,
    invoice_no: int,
    item_update: schemas.SaleItemUpdate
):
    """
    Update sale item by invoice number. Allows changing product_id, quantity, and selling_price.
    """

    # üîç Fetch the sale item using invoice_no + optional product_id in the payload
    query = db.query(models.SaleItem).filter(models.SaleItem.sale_invoice_no == invoice_no)

    # If updating a specific product_id, fetch that
    if item_update.old_product_id is not None:
        query = query.filter(models.SaleItem.product_id == item_update.old_product_id)

    item = query.first()

    if not item:
        raise HTTPException(status_code=404, detail="Sale item not found for this invoice")

    # ‚úÖ Update product if provided
    if item_update.product_id is not None:
        # Make sure no duplicate product exists for the same invoice
        existing_item = db.query(models.SaleItem).filter(
            models.SaleItem.sale_invoice_no == invoice_no,
            models.SaleItem.product_id == item_update.product_id
        ).first()
        if existing_item and existing_item.id != item.id:
            raise HTTPException(
                status_code=400,
                detail="This product already exists in the invoice"
            )
        item.product_id = item_update.product_id

    # ‚úÖ Update quantity and price
    if item_update.quantity is not None:
        item.quantity = item_update.quantity

    if item_update.selling_price is not None:
        item.selling_price = item_update.selling_price

    # üîÅ Recalculate totals
    item.total_amount = item.quantity * item.selling_price

    sale = db.query(models.Sale).filter(models.Sale.invoice_no == invoice_no).first()
    if sale:
        sale.total_amount = sum(i.total_amount for i in sale.items)

    db.commit()
    db.refresh(item)
    return item


def _attach_payment_totals(sale):
    total_paid = sum(p.amount_paid for p in sale.payments)
    sale.total_paid = total_paid
    sale.balance_due = sale.total_amount - total_paid





def staff_sales_report(
    db: Session,
    staff_id: Optional[int] = None,
    start_date=None,
    end_date=None
):
    query = (
        db.query(models.Sale)
        .join(User, models.Sale.sold_by == User.id)
        .options(
            joinedload(models.Sale.items)
            .joinedload(models.SaleItem.product)
        )
    )

    # Filter by staff (user)
    if staff_id:
        query = query.filter(models.Sale.sold_by == staff_id)

    # Date filters
    if start_date:
        query = query.filter(
            models.Sale.sold_at >= datetime.combine(start_date, time.min)
        )

    if end_date:
        query = query.filter(
            models.Sale.sold_at <= datetime.combine(end_date, time.max)
        )

    sales = query.order_by(models.Sale.sold_at.desc()).all()

    for sale in sales:
        _attach_payment_totals(sale)

        sale.customer_name = sale.customer_name or "Walk-in"
        sale.customer_phone = sale.customer_phone or "-"
        sale.ref_no = sale.ref_no or "-"

        # üî• Attach staff name from User
        sale.staff_name = (
            sale.user.username
            if sale.user else "-"
        )


        for item in sale.items:
            item.product_name = item.product.name if item.product else "-"

    return sales




from datetime import datetime, timedelta

from sqlalchemy import cast, Date
from datetime import datetime, date

def outstanding_sales_service(
    db: Session,
    start_date: date | None = None,
    end_date: date | None = None,
    customer_name: str | None = None
):
    """
    Returns all outstanding sales (balance > 0) for given date range
    and optional customer name filter.
    Dates are date objects.
    """

    # Default to today if no date provided
    today = datetime.now().date()
    start_date = start_date or today
    end_date = end_date or today

    # Base query
    query = db.query(models.Sale).filter(models.Sale.sold_at != None)

    # Filter by date only (ignores time)
    query = query.filter(
        cast(models.Sale.sold_at, Date) >= start_date,
        cast(models.Sale.sold_at, Date) <= end_date
    )

    # Customer filter
    if customer_name:
        query = query.filter(models.Sale.customer_name.ilike(f"%{customer_name}%"))

    sales = query.all()

    sales_list = []
    sales_sum = 0.0
    paid_sum = 0.0
    balance_sum = 0.0

    for sale in sales:
        total_amount = sale.total_amount or 0
        total_paid = sum((p.amount_paid or 0) for p in getattr(sale, "payments", []))
        balance = total_amount - total_paid

        if balance <= 0:
            continue  # Skip fully paid

        # Build items
        items = []
        for item in getattr(sale, "items", []):
            items.append({
                "id": item.id,
                "sale_invoice_no": sale.invoice_no,
                "product_id": item.product_id,
                "product_name": getattr(item.product, "name", None) if getattr(item, "product", None) else None,
                "quantity": item.quantity or 0,
                "selling_price": item.selling_price or 0,
                "total_amount": item.total_amount or 0,
            })

        sales_list.append({
            "id": sale.id,
            "invoice_no": sale.invoice_no,
            "invoice_date": sale.invoice_date.strftime("%Y-%m-%d") if sale.invoice_date else None,
            "customer_name": sale.customer_name or "",
            "customer_phone": sale.customer_phone or "",
            "ref_no": sale.ref_no or "",
            "total_amount": total_amount,
            "total_paid": total_paid,
            "balance_due": balance,
            "items": items
        })

        sales_sum += total_amount
        paid_sum += total_paid
        balance_sum += balance

    return {
        "sales": sales_list,
        "summary": {
            "sales_sum": sales_sum,
            "paid_sum": paid_sum,
            "balance_sum": balance_sum
        }
    }




def sales_analysis(db: Session, start_date=None, end_date=None):

    # üîπ Latest purchase cost per product
    latest_purchase = (
        db.query(
            Purchase.product_id,
            Purchase.cost_price
        )
        .order_by(Purchase.product_id, desc(Purchase.id))
        .distinct(Purchase.product_id)
        .subquery()
    )

    query = (
        db.query(
            models.SaleItem.product_id,
            Product.name.label("product_name"),

            # ‚úÖ Total quantity sold
            func.sum(models.SaleItem.quantity).label("quantity_sold"),

            # ‚úÖ Weighted average selling price
            (
                func.sum(models.SaleItem.selling_price * models.SaleItem.quantity)
                / func.nullif(func.sum(models.SaleItem.quantity), 0)
            ).label("avg_selling_price"),

            latest_purchase.c.cost_price
        )

        # ‚úÖ CORRECT JOIN (invoice-based)
        .join(
            models.Sale,
            models.Sale.invoice_no == models.SaleItem.sale_invoice_no
        )

        .join(Product, Product.id == models.SaleItem.product_id)

        .outerjoin(
            latest_purchase,
            latest_purchase.c.product_id == models.SaleItem.product_id
        )
    )

    # üîπ Date filters (now safe & correct)
    if start_date:
        query = query.filter(
            models.Sale.sold_at >= datetime.combine(start_date, time.min)
        )

    if end_date:
        query = query.filter(
            models.Sale.sold_at <= datetime.combine(end_date, time.max)
        )

    query = query.group_by(
        models.SaleItem.product_id,
        Product.name,
        latest_purchase.c.cost_price
    )

    results = query.all()

    items = []
    total_sales = 0.0
    total_margin = 0.0

    for row in results:
        cost_price = row.cost_price or 0.0
        selling_price = row.avg_selling_price or 0.0
        quantity = int(row.quantity_sold or 0)

        product_total_sales = quantity * selling_price
        product_margin = (selling_price - cost_price) * quantity

        total_sales += product_total_sales
        total_margin += product_margin

        items.append({
            "product_id": row.product_id,
            "product_name": row.product_name,
            "quantity_sold": quantity,
            "cost_price": cost_price,
            "selling_price": selling_price,
            "total_sales": product_total_sales,
            "margin": product_margin
        })

    return {
        "items": items,
        "total_sales": total_sales,
        "total_margin": total_margin
    }





from datetime import datetime, time

def get_sales_by_customer(
    db: Session,
    customer_name: str | None = None,
    start_date: date | None = None,
    end_date: date | None = None
):
    # üî¥ HARD RESTRICTION
    if not customer_name or not customer_name.strip():
        return []

    query = (
        db.query(models.Sale)
        .options(
            joinedload(models.Sale.items)
            .joinedload(models.SaleItem.product)
        )
        .filter(
            models.Sale.customer_name.ilike(f"%{customer_name.strip()}%")
        )
    )

    # ‚úÖ Start date ‚Üí beginning of day
    if start_date:
        start_dt = datetime.combine(start_date, time.min)
        query = query.filter(models.Sale.sold_at >= start_dt)

    # ‚úÖ End date ‚Üí END of day (THIS IS THE KEY FIX)
    if end_date:
        end_dt = datetime.combine(end_date, time.max)
        query = query.filter(models.Sale.sold_at <= end_dt)

    sales = query.order_by(models.Sale.sold_at.desc()).all()

    # Normalize fields
    for sale in sales:
        sale.customer_name = sale.customer_name or "Walk-in"
        sale.customer_phone = sale.customer_phone or "-"
        sale.ref_no = sale.ref_no or "-"

        for item in sale.items:
            item.product_name = item.product.name if item.product else "-"

    return sales



def delete_sale(db: Session, invoice_no: int):
    # 1Ô∏è‚É£ Fetch sale by invoice_no
    sale = db.query(models.Sale).filter(models.Sale.invoice_no == invoice_no).first()
    if not sale:
        raise HTTPException(status_code=404, detail="Sale not found")

    # 2Ô∏è‚É£ Restore inventory for each sale item
    for item in sale.items:
        inventory = inventory_service.get_inventory_orm_by_product(db, item.product_id)
        if inventory:
            inventory.quantity_out -= item.quantity
            inventory.current_stock = (
                inventory.quantity_in - inventory.quantity_out + inventory.adjustment_total
            )
            db.add(inventory)

    # 3Ô∏è‚É£ Delete sale (SaleItems will be deleted automatically if FK is ON DELETE CASCADE)
    db.delete(sale)
    db.commit()

    return {"detail": f"Sale {invoice_no} deleted successfully"}






def delete_all_sales(db: Session):
    sales = db.query(models.Sale).all()

    if not sales:
        return {
            "message": "No sales to delete",
            "deleted_count": 0
        }

    deleted_count = 0

    for sale in sales:
        # 1Ô∏è‚É£ Restore inventory for each sale item
        for item in sale.items:
            inventory = inventory_service.get_inventory_orm_by_product(
                db, item.product_id
            )
            if inventory:
                inventory.quantity_out -= item.quantity
                inventory.current_stock = (
                    inventory.quantity_in
                    - inventory.quantity_out
                    + inventory.adjustment_total
                )
                db.add(inventory)

        # 2Ô∏è‚É£ Delete sale (SaleItems cascade if FK is ON DELETE CASCADE)
        db.delete(sale)
        deleted_count += 1

    # 3Ô∏è‚É£ OPTIONAL: reset invoice number sequence
    # ‚ö†Ô∏è Only do this if you REALLY want invoices to restart
    db.execute(
        text("ALTER SEQUENCE sales_invoice_no_seq RESTART WITH 1")
    )

    db.commit()

    return {
        "message": "All sales deleted successfully and stock restored",
        "deleted_count": deleted_count
    }

