from sqlalchemy.orm import Session
from fastapi import HTTPException
from datetime import datetime
from typing import Optional
from datetime import datetime, time
from datetime import date
from sqlalchemy.orm import joinedload


from . import models, schemas
from app.stock.inventory import service as inventory_service
from app.stock.products import models as product_models

from app.sales.schemas import SaleOut, SaleOut2, SaleSummary, SalesListResponse, SaleItemOut2

from app.stock.products import models as product_models
from app.payments.models import Payment

from sqlalchemy import func
from app.stock.products.models import Product

from sqlalchemy import func, desc
from sqlalchemy import text

from app.purchase.models import Purchase





def create_sale_full(
    db: Session,
    sale_data: schemas.SaleFullCreate,
    user_id: int
):
    """
    Create a sale with all items in one transaction.
    Invoice number is auto-generated by PostgreSQL.
    Allows negative stock but returns warnings.
    """

    warnings = []  # üî• collect stock warnings

    # 1Ô∏è‚É£ Create Sale Header
    sale = models.Sale(
        invoice_date=sale_data.invoice_date,
        customer_name=sale_data.customer_name,
        customer_phone=sale_data.customer_phone,
        ref_no=sale_data.ref_no,
        sold_by=user_id,
        total_amount=0

    )

    db.add(sale)
    db.commit()
    db.refresh(sale)

    total_amount = 0

    # 2Ô∏è‚É£ Process Sale Items
    for item in sale_data.items:

        # üîπ Validate product
        product = (
            db.query(product_models.Product)
            .filter(product_models.Product.id == item.product_id)
            .first()
        )

        if not product:
            raise HTTPException(
                status_code=404,
                detail=f"Product {item.product_id} not found"
            )

        # üîπ Check stock (NO BLOCKING)
        stock = inventory_service.get_inventory_by_product(
            db, item.product_id
        )

        if not stock:
            warnings.append(
                f"No stock record for {product.name}. Sale allowed."
            )
        elif stock.current_stock < item.quantity:
            warnings.append(
                f"Insufficient stock for {product.name}. "
                f"Available: {stock.current_stock}, Sold: {item.quantity}"
            )

        # üîπ Deduct stock anyway (can go negative)
        inventory_service.remove_stock(
            db,
            item.product_id,
            item.quantity,
            commit=False
        )

        # üîπ Calculate totals
        item_total = item.quantity * item.selling_price

        sale_item = models.SaleItem(
            sale_invoice_no=sale.invoice_no,
            product_id=item.product_id,
            quantity=item.quantity,
            selling_price=item.selling_price,
            total_amount=item_total
        )

        total_amount += item_total
        db.add(sale_item)

    # 3Ô∏è‚É£ Update Sale Total
    sale.total_amount = total_amount
    db.commit()
    db.refresh(sale)

    # üî• Attach warnings dynamically
    sale.warnings = warnings

    return sale


# ============================================================
# ADD SINGLE ITEM TO EXISTING SALE
# ============================================================

def create_sale_item(
    db: Session,
    item: schemas.SaleItemCreate
):
    """
    Add a single item to an existing sale.
    Invoice number remains unchanged.
    """

    # ‚úÖ Find sale using invoice_no
    sale = (
        db.query(models.Sale)
        .filter(models.Sale.invoice_no == item.sale_invoice_no)
        .first()
    )
    if not sale:
        raise HTTPException(
            status_code=404,
            detail="Sale not found"
        )

    # Validate product
    product = (
        db.query(product_models.Product)
        .filter(product_models.Product.id == item.product_id)
        .first()
    )
    if not product:
        raise HTTPException(
            status_code=404,
            detail="Product not found"
        )

    # Validate stock
    stock = inventory_service.get_inventory_by_product(
        db, item.product_id
    )
    if not stock or stock.current_stock < item.quantity:
        raise HTTPException(
            status_code=400,
            detail="Insufficient stock"
        )

    # Deduct stock
    inventory_service.remove_stock(
        db,
        item.product_id,
        item.quantity,
        commit=False
    )

    total = item.quantity * item.selling_price

    # ‚úÖ USE invoice_no
    sale_item = models.SaleItem(
        sale_invoice_no=item.sale_invoice_no,
        product_id=item.product_id,
        quantity=item.quantity,
        selling_price=item.selling_price,
        total_amount=total
    )

    # Update sale total
    sale.total_amount += total

    db.add(sale_item)
    db.commit()
    db.refresh(sale_item)

    return sale_item


    


def list_item_sold(
    db: Session,
    start_date: date,
    end_date: date,
    invoice_no: Optional[int] = None,
    skip: int = 0,
    limit: int = 100
):
    # Query sales with items and product relationship loaded
    query = (
        db.query(models.Sale)
        .options(
            joinedload(models.Sale.items).joinedload(models.SaleItem.product)
        )
        .filter(models.Sale.invoice_date >= start_date)
        .filter(models.Sale.invoice_date <= end_date)
    )

    if invoice_no:
        query = query.filter(models.Sale.invoice_no == invoice_no)

    sales = (
        query
        .order_by(models.Sale.invoice_no.desc())
        .offset(skip)
        .limit(limit)
        .all()
    )

    # Add product_name to each item manually
    for sale in sales:
        for item in sale.items:
            # Set product_name from the relationship
            item.product_name = item.product.name if item.product else None

    return sales



def list_sales(
    db: Session,
    skip: int = 0,
    limit: int = 100,
    start_date: Optional[datetime.date] = None,
    end_date: Optional[datetime.date] = None
):
    query = db.query(models.Sale)

    # ‚úÖ Safe date filters
    try:
        if start_date:
            query = query.filter(models.Sale.sold_at >= datetime.combine(start_date, time.min))
        if end_date:
            query = query.filter(models.Sale.sold_at <= datetime.combine(end_date, time.max))
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Invalid date filter: {e}")

    # Fetch sales
    sales = query.order_by(models.Sale.sold_at.desc()).offset(skip).limit(limit).all()

    sales_list = []
    total_sales_amount = 0.0
    total_paid_sum = 0.0
    total_balance_sum = 0.0

    for sale in sales:
        total_amount = float(sale.total_amount or 0)
        payments = getattr(sale, "payments", []) or []
        total_paid = sum(float(p.amount_paid or 0) for p in payments)
        balance_due = total_amount - total_paid

        if total_paid == 0:
            status = "pending"
        elif balance_due > 0:
            status = "part_paid"
        else:
            status = "completed"

        sales_list.append(
            SaleOut2(
                id=sale.id,
                invoice_no=sale.invoice_no,
                invoice_date=sale.invoice_date,
                customer_name=sale.customer_name or "Walk-in",
                customer_phone=getattr(sale, "customer_phone", None),
                total_amount=total_amount,
                total_paid=total_paid,
                balance_due=balance_due,
                payment_status=status,
                sold_at=sale.sold_at,
                items=[
                    SaleItemOut2.model_validate(item)
                    for item in (sale.items or [])
                ]

            )
        )

        total_sales_amount += total_amount
        total_paid_sum += total_paid
        total_balance_sum += balance_due

    summary = SaleSummary(
        total_sales=total_sales_amount,
        total_paid=total_paid_sum,
        total_balance=total_balance_sum
    )

    return SalesListResponse(sales=sales_list, summary=summary)




def update_sale(db: Session, invoice_no: int, sale_update: schemas.SaleUpdate):
    sale = (
        db.query(models.Sale)
        .filter(models.Sale.invoice_no == invoice_no)
        .first()
    )

    if not sale:
        raise HTTPException(status_code=404, detail="Sale not found")

    update_data = sale_update.dict(exclude_unset=True)

    # üî• SAFETY GUARD
    if "invoice_no" in update_data:
        raise HTTPException(
            status_code=400,
            detail="Invoice number cannot be updated"
        )

    for field, value in update_data.items():
        setattr(sale, field, value)

    # totals must come from items
    sale.total_amount = sum(item.total_amount for item in sale.items)

    total_paid = sum(p.amount_paid for p in sale.payments)
    sale.balance_due = sale.total_amount - total_paid

    db.commit()
    db.refresh(sale)

    return sale

def update_sale_item(
    db: Session,
    invoice_no: int,
    product_id: int,
    item_update: schemas.SaleItemUpdate
):
    # üîç Fetch item by invoice_no + product_id
    item = (
        db.query(models.SaleItem)
        .filter(
            models.SaleItem.sale_invoice_no == invoice_no,
            models.SaleItem.product_id == product_id
        )
        .first()
    )

    if not item:
        raise HTTPException(
            status_code=404,
            detail="Sale item not found for this invoice"
        )

    inventory = inventory_service.get_inventory_by_product(db, product_id)

    # üßÆ Stock adjustment
    if item_update.quantity is not None:
        qty_diff = item_update.quantity - item.quantity

        if qty_diff > 0:
            # Need extra stock
            if not inventory or inventory.current_stock < qty_diff:
                raise HTTPException(
                    status_code=400,
                    detail="Insufficient stock for update"
                )

            inventory_service.remove_stock(
                db, product_id, qty_diff, commit=False
            )

        elif qty_diff < 0:
            # Restore stock
            inventory.quantity_out += qty_diff  # qty_diff is negative
            inventory.current_stock = (
                inventory.quantity_in
                - inventory.quantity_out
                + inventory.adjustment_total
            )

        item.quantity = item_update.quantity

    if item_update.selling_price is not None:
        item.selling_price = item_update.selling_price

    # üîÅ Recalculate item total
    item.total_amount = item.quantity * item.selling_price

    # üîÅ Recalculate sale total (invoice-based)
    sale = (
        db.query(models.Sale)
        .filter(models.Sale.invoice_no == invoice_no)
        .first()
    )

    sale.total_amount = sum(i.total_amount for i in sale.items)

    db.commit()
    db.refresh(item)

    return item


def _attach_payment_totals(sale):
    total_paid = sum(p.amount_paid for p in sale.payments)
    sale.total_paid = total_paid
    sale.balance_due = sale.total_amount - total_paid




def staff_sales_report(
    db: Session,
    staff_id: Optional[int] = None,
    start_date=None,
    end_date=None
):
    # Query sales with items and product relationship loaded
    query = db.query(models.Sale).options(
        joinedload(models.Sale.items).joinedload(models.SaleItem.product)
    )

    # Filter by staff
    if staff_id:
        query = query.filter(models.Sale.sold_by == staff_id)

    # Date filters
    if start_date:
        query = query.filter(
            models.Sale.sold_at >= datetime.combine(start_date, time.min)
        )

    if end_date:
        query = query.filter(
            models.Sale.sold_at <= datetime.combine(end_date, time.max)
        )

    sales = (
        query
        .order_by(models.Sale.sold_at.desc())
        .all()
    )

    # Attach payments and product names
    for sale in sales:
        # Compute total payments, balance, etc.
        _attach_payment_totals(sale)

        # Set product_name for each item
        for item in sale.items:
            item.product_name = item.product.name if item.product else None

    return sales




def outstanding_sales_service(db: Session, start_date=None, end_date=None):
    query = db.query(models.Sale)

    if start_date:
        query = query.filter(models.Sale.sold_at >= start_date)

    if end_date:
        query = query.filter(models.Sale.sold_at <= end_date)

    sales = query.all()

    sales_list = []

    sales_sum = 0.0
    paid_sum = 0.0
    balance_sum = 0.0

    for sale in sales:
        total_paid = sum(p.amount_paid for p in sale.payments)
        balance = sale.total_amount - total_paid

        if balance > 0:
            sales_list.append({
                "id": sale.id,
                "invoice_no": sale.invoice_no,
                "invoice_date": sale.invoice_date,
                "customer_name": sale.customer_name,
                "customer_phone": sale.customer_phone,
                "ref_no": sale.ref_no,
                "total_amount": sale.total_amount,
                "total_paid": total_paid,
                "balance_due": balance,
                "items": sale.items
            })

            sales_sum += sale.total_amount
            paid_sum += total_paid
            balance_sum += balance

    return {
        "sales": sales_list,
        "summary": {
            "sales_sum": sales_sum,
            "paid_sum": paid_sum,
            "balance_sum": balance_sum
        }
    }






def delete_sale(db: Session, invoice_no: int):
    # 1Ô∏è‚É£ Fetch sale by invoice_no
    sale = db.query(models.Sale).filter(models.Sale.invoice_no == invoice_no).first()
    if not sale:
        raise HTTPException(status_code=404, detail="Sale not found")

    # 2Ô∏è‚É£ Restore inventory for each sale item
    for item in sale.items:
        inventory = inventory_service.get_inventory_by_product(db, item.product_id)
        if inventory:
            inventory.quantity_out -= item.quantity
            inventory.current_stock = (
                inventory.quantity_in - inventory.quantity_out + inventory.adjustment_total
            )
            db.add(inventory)

    # 3Ô∏è‚É£ Delete sale (SaleItems will be deleted automatically if FK is ON DELETE CASCADE)
    db.delete(sale)
    db.commit()

    return {"detail": f"Sale {invoice_no} deleted successfully"}




def sales_analysis(db: Session, start_date=None, end_date=None):
    # Subquery: latest purchase per product
    latest_purchase = (
        db.query(
            Purchase.product_id,
            Purchase.cost_price
        )
        .order_by(Purchase.product_id, desc(Purchase.id))  # fixed
        .distinct(Purchase.product_id)
        .subquery()
    )

    query = (
        db.query(
            models.SaleItem.product_id,
            Product.name.label("product_name"),
            func.sum(models.SaleItem.quantity).label("quantity_sold"),
            func.avg(models.SaleItem.selling_price).label("avg_selling_price"),
            latest_purchase.c.cost_price
        )
        .join(Product, Product.id == models.SaleItem.product_id)
        .outerjoin(latest_purchase, latest_purchase.c.product_id == models.SaleItem.product_id)
    )

    # Apply date filters
    if start_date:
        query = query.filter(models.Sale.sold_at >= datetime.combine(start_date, time.min))
    if end_date:
        query = query.filter(models.Sale.sold_at <= datetime.combine(end_date, time.max))

    query = query.group_by(
        models.SaleItem.product_id,
        Product.name,
        latest_purchase.c.cost_price
    )

    results = query.all()

    items = []
    total_sales = 0.0
    total_margin = 0.0

    for row in results:
        cost_price = row.cost_price or 0.0
        selling_price = row.avg_selling_price or 0.0

        product_total_sales = row.quantity_sold * selling_price
        product_margin = (selling_price - cost_price) * row.quantity_sold

        total_sales += product_total_sales
        total_margin += product_margin

        items.append({
            "product_id": row.product_id,
            "product_name": row.product_name,
            "quantity_sold": row.quantity_sold,
            "cost_price": cost_price,
            "selling_price": selling_price,
            "total_sales": product_total_sales,
            "margin": product_margin
        })

    return {
        "items": items,
        "total_sales": total_sales,
        "total_margin": total_margin
    }




def delete_all_sales(db: Session):
    sales = db.query(models.Sale).all()

    if not sales:
        return {
            "message": "No sales to delete",
            "deleted_count": 0
        }

    deleted_count = 0

    for sale in sales:
        # 1Ô∏è‚É£ Restore inventory for each sale item
        for item in sale.items:
            inventory = inventory_service.get_inventory_by_product(
                db, item.product_id
            )
            if inventory:
                inventory.quantity_out -= item.quantity
                inventory.current_stock = (
                    inventory.quantity_in
                    - inventory.quantity_out
                    + inventory.adjustment_total
                )
                db.add(inventory)

        # 2Ô∏è‚É£ Delete sale (SaleItems cascade if FK is ON DELETE CASCADE)
        db.delete(sale)
        deleted_count += 1

    # 3Ô∏è‚É£ OPTIONAL: reset invoice number sequence
    # ‚ö†Ô∏è Only do this if you REALLY want invoices to restart
    db.execute(
        text("ALTER SEQUENCE sales_invoice_no_seq RESTART WITH 1")
    )

    db.commit()

    return {
        "message": "All sales deleted successfully and stock restored",
        "deleted_count": deleted_count
    }




from sqlalchemy.orm import joinedload

def get_sales_by_customer(
    db: Session,
    customer_name: str | None = None,
    customer_phone: str | None = None
):
    query = (
        db.query(models.Sale)
        .options(
            joinedload(models.Sale.items)
            .joinedload(models.SaleItem.product)
        )
    )

    if customer_name:
        query = query.filter(
            models.Sale.customer_name.ilike(f"%{customer_name}%")
        )

    if customer_phone:
        query = query.filter(
            models.Sale.customer_phone.ilike(f"%{customer_phone}%")
        )

    sales = query.order_by(models.Sale.sold_at.desc()).all()

    # Attach product_name safely
    for sale in sales:
        for item in sale.items:
            item.product_name = item.product.name if item.product else None

    return sales
