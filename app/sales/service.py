from sqlalchemy.orm import Session
from fastapi import HTTPException
from datetime import datetime

from . import models, schemas
from app.stock.inventory import service as inventory_service
from app.stock.products import models as product_models


from app.stock.products import models as product_models
from app.payments.models import Payment

from sqlalchemy import func
from app.stock.products.models import Product

from sqlalchemy import func, desc
from sqlalchemy import text

from app.purchase.models import Purchase




def create_sale_full(
    db: Session,
    sale_data: schemas.SaleFullCreate,
    user_id: int
):
    """
    Create a sale with all items in one transaction.
    Invoice number is auto-generated by PostgreSQL.
    Allows negative stock but returns warnings.
    """

    warnings = []  # üî• collect stock warnings

    # 1Ô∏è‚É£ Create Sale Header
    sale = models.Sale(
        invoice_date=sale_data.invoice_date,
        customer_name=sale_data.customer_name,
        customer_phone=sale_data.customer_phone,
        ref_no=sale_data.ref_no,
        sold_by=user_id,
        total_amount=0
    )

    db.add(sale)
    db.commit()
    db.refresh(sale)

    total_amount = 0

    # 2Ô∏è‚É£ Process Sale Items
    for item in sale_data.items:

        # üîπ Validate product
        product = (
            db.query(product_models.Product)
            .filter(product_models.Product.id == item.product_id)
            .first()
        )

        if not product:
            raise HTTPException(
                status_code=404,
                detail=f"Product {item.product_id} not found"
            )

        # üîπ Check stock (NO BLOCKING)
        stock = inventory_service.get_inventory_by_product(
            db, item.product_id
        )

        if not stock:
            warnings.append(
                f"No stock record for {product.name}. Sale allowed."
            )
        elif stock.current_stock < item.quantity:
            warnings.append(
                f"Insufficient stock for {product.name}. "
                f"Available: {stock.current_stock}, Sold: {item.quantity}"
            )

        # üîπ Deduct stock anyway (can go negative)
        inventory_service.remove_stock(
            db,
            item.product_id,
            item.quantity,
            commit=False
        )

        # üîπ Calculate totals
        item_total = item.quantity * item.selling_price

        sale_item = models.SaleItem(
            sale_invoice_no=sale.invoice_no,
            product_id=item.product_id,
            quantity=item.quantity,
            selling_price=item.selling_price,
            total_amount=item_total
        )

        total_amount += item_total
        db.add(sale_item)

    # 3Ô∏è‚É£ Update Sale Total
    sale.total_amount = total_amount
    db.commit()
    db.refresh(sale)

    # üî• Attach warnings dynamically
    sale.warnings = warnings

    return sale


# ============================================================
# ADD SINGLE ITEM TO EXISTING SALE
# ============================================================

def create_sale_item(
    db: Session,
    item: schemas.SaleItemCreate
):
    """
    Add a single item to an existing sale.
    Invoice number remains unchanged.
    """

    # ‚úÖ Find sale using invoice_no
    sale = (
        db.query(models.Sale)
        .filter(models.Sale.invoice_no == item.sale_invoice_no)
        .first()
    )
    if not sale:
        raise HTTPException(
            status_code=404,
            detail="Sale not found"
        )

    # Validate product
    product = (
        db.query(product_models.Product)
        .filter(product_models.Product.id == item.product_id)
        .first()
    )
    if not product:
        raise HTTPException(
            status_code=404,
            detail="Product not found"
        )

    # Validate stock
    stock = inventory_service.get_inventory_by_product(
        db, item.product_id
    )
    if not stock or stock.current_stock < item.quantity:
        raise HTTPException(
            status_code=400,
            detail="Insufficient stock"
        )

    # Deduct stock
    inventory_service.remove_stock(
        db,
        item.product_id,
        item.quantity,
        commit=False
    )

    total = item.quantity * item.selling_price

    # ‚úÖ USE invoice_no
    sale_item = models.SaleItem(
        sale_invoice_no=item.sale_invoice_no,
        product_id=item.product_id,
        quantity=item.quantity,
        selling_price=item.selling_price,
        total_amount=total
    )

    # Update sale total
    sale.total_amount += total

    db.add(sale_item)
    db.commit()
    db.refresh(sale_item)

    return sale_item


    
def get_sale(db: Session, invoice_no: int):
    sale = (
        db.query(models.Sale)
        .filter(models.Sale.invoice_no == invoice_no)
        .first()
    )

    if not sale:
        raise HTTPException(status_code=404, detail="Sale not found")

    # Compute payments
    total_paid = sum(p.amount_paid for p in sale.payments)
    sale.total_paid = total_paid
    sale.balance_due = sale.total_amount - total_paid

    return sale

from datetime import datetime, time

def list_sales(
    db: Session,
    skip: int = 0,
    limit: int = 100,
    start_date=None,
    end_date=None
):
    query = db.query(models.Sale)

    # Date filtering
    if start_date:
        query = query.filter(
            models.Sale.sold_at >= datetime.combine(start_date, time.min)
        )

    if end_date:
        query = query.filter(
            models.Sale.sold_at <= datetime.combine(end_date, time.max)
        )

    sales = (
        query
        .order_by(models.Sale.sold_at.desc())
        .offset(skip)
        .limit(limit)
        .all()
    )

    # Computed fields
    for sale in sales:
        total_paid = sum(p.amount_paid for p in sale.payments)
        sale.total_paid = total_paid
        sale.balance_due = sale.total_amount - total_paid

    return sales


from fastapi import HTTPException
from sqlalchemy.orm import Session
from . import models, schemas

def update_sale(db: Session, invoice_no: int, sale_update: schemas.SaleUpdate):
    sale = (
        db.query(models.Sale)
        .filter(models.Sale.invoice_no == invoice_no)
        .first()
    )

    if not sale:
        raise HTTPException(status_code=404, detail="Sale not found")

    update_data = sale_update.dict(exclude_unset=True)

    # üî• SAFETY GUARD
    if "invoice_no" in update_data:
        raise HTTPException(
            status_code=400,
            detail="Invoice number cannot be updated"
        )

    for field, value in update_data.items():
        setattr(sale, field, value)

    # totals must come from items
    sale.total_amount = sum(item.total_amount for item in sale.items)

    total_paid = sum(p.amount_paid for p in sale.payments)
    sale.balance_due = sale.total_amount - total_paid

    db.commit()
    db.refresh(sale)

    return sale

def update_sale_item(
    db: Session,
    invoice_no: int,
    product_id: int,
    item_update: schemas.SaleItemUpdate
):
    # üîç Fetch item by invoice_no + product_id
    item = (
        db.query(models.SaleItem)
        .filter(
            models.SaleItem.sale_invoice_no == invoice_no,
            models.SaleItem.product_id == product_id
        )
        .first()
    )

    if not item:
        raise HTTPException(
            status_code=404,
            detail="Sale item not found for this invoice"
        )

    inventory = inventory_service.get_inventory_by_product(db, product_id)

    # üßÆ Stock adjustment
    if item_update.quantity is not None:
        qty_diff = item_update.quantity - item.quantity

        if qty_diff > 0:
            # Need extra stock
            if not inventory or inventory.current_stock < qty_diff:
                raise HTTPException(
                    status_code=400,
                    detail="Insufficient stock for update"
                )

            inventory_service.remove_stock(
                db, product_id, qty_diff, commit=False
            )

        elif qty_diff < 0:
            # Restore stock
            inventory.quantity_out += qty_diff  # qty_diff is negative
            inventory.current_stock = (
                inventory.quantity_in
                - inventory.quantity_out
                + inventory.adjustment_total
            )

        item.quantity = item_update.quantity

    if item_update.selling_price is not None:
        item.selling_price = item_update.selling_price

    # üîÅ Recalculate item total
    item.total_amount = item.quantity * item.selling_price

    # üîÅ Recalculate sale total (invoice-based)
    sale = (
        db.query(models.Sale)
        .filter(models.Sale.invoice_no == invoice_no)
        .first()
    )

    sale.total_amount = sum(i.total_amount for i in sale.items)

    db.commit()
    db.refresh(item)

    return item





def delete_sale(db: Session, invoice_no: int):
    # 1Ô∏è‚É£ Fetch sale by invoice_no
    sale = db.query(models.Sale).filter(models.Sale.invoice_no == invoice_no).first()
    if not sale:
        raise HTTPException(status_code=404, detail="Sale not found")

    # 2Ô∏è‚É£ Restore inventory for each sale item
    for item in sale.items:
        inventory = inventory_service.get_inventory_by_product(db, item.product_id)
        if inventory:
            inventory.quantity_out -= item.quantity
            inventory.current_stock = (
                inventory.quantity_in - inventory.quantity_out + inventory.adjustment_total
            )
            db.add(inventory)

    # 3Ô∏è‚É£ Delete sale (SaleItems will be deleted automatically if FK is ON DELETE CASCADE)
    db.delete(sale)
    db.commit()

    return {"detail": f"Sale {invoice_no} deleted successfully"}




def sales_analysis(db: Session, start_date=None, end_date=None):
    # Subquery: latest purchase per product
    latest_purchase = (
        db.query(
            Purchase.product_id,
            Purchase.cost_price
        )
        .order_by(Purchase.product_id, desc(Purchase.id))  # fixed
        .distinct(Purchase.product_id)
        .subquery()
    )

    query = (
        db.query(
            models.SaleItem.product_id,
            Product.name.label("product_name"),
            func.sum(models.SaleItem.quantity).label("quantity_sold"),
            func.avg(models.SaleItem.selling_price).label("avg_selling_price"),
            latest_purchase.c.cost_price
        )
        .join(Product, Product.id == models.SaleItem.product_id)
        .outerjoin(latest_purchase, latest_purchase.c.product_id == models.SaleItem.product_id)
    )

    # Apply date filters
    if start_date:
        query = query.filter(models.Sale.sold_at >= datetime.combine(start_date, time.min))
    if end_date:
        query = query.filter(models.Sale.sold_at <= datetime.combine(end_date, time.max))

    query = query.group_by(
        models.SaleItem.product_id,
        Product.name,
        latest_purchase.c.cost_price
    )

    results = query.all()

    items = []
    total_sales = 0.0
    total_margin = 0.0

    for row in results:
        cost_price = row.cost_price or 0.0
        selling_price = row.avg_selling_price or 0.0

        product_total_sales = row.quantity_sold * selling_price
        product_margin = (selling_price - cost_price) * row.quantity_sold

        total_sales += product_total_sales
        total_margin += product_margin

        items.append({
            "product_id": row.product_id,
            "product_name": row.product_name,
            "quantity_sold": row.quantity_sold,
            "cost_price": cost_price,
            "selling_price": selling_price,
            "total_sales": product_total_sales,
            "margin": product_margin
        })

    return {
        "items": items,
        "total_sales": total_sales,
        "total_margin": total_margin
    }




def delete_all_sales(db: Session):
    sales = db.query(models.Sale).all()

    if not sales:
        return {
            "message": "No sales to delete",
            "deleted_count": 0
        }

    deleted_count = 0

    for sale in sales:
        # 1Ô∏è‚É£ Restore inventory for each sale item
        for item in sale.items:
            inventory = inventory_service.get_inventory_by_product(
                db, item.product_id
            )
            if inventory:
                inventory.quantity_out -= item.quantity
                inventory.current_stock = (
                    inventory.quantity_in
                    - inventory.quantity_out
                    + inventory.adjustment_total
                )
                db.add(inventory)

        # 2Ô∏è‚É£ Delete sale (SaleItems cascade if FK is ON DELETE CASCADE)
        db.delete(sale)
        deleted_count += 1

    # 3Ô∏è‚É£ OPTIONAL: reset invoice number sequence
    # ‚ö†Ô∏è Only do this if you REALLY want invoices to restart
    db.execute(
        text("ALTER SEQUENCE sales_invoice_no_seq RESTART WITH 1")
    )

    db.commit()

    return {
        "message": "All sales deleted successfully and stock restored",
        "deleted_count": deleted_count
    }